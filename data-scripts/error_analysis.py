# Original Author: Theresa Schmidt, 2021 <theresas@coli.uni-saarland.de>
# Revised: Siyu Tao, 2022
# Last Edit: 2022/07/06

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""
Creates tsv files for error analysis from our tagger's or parser's output files.

Takes AllenNLP prediction for sequence tags and complementary annotated (gold) file. 
Prints all columns of the annotated file plus an extra column for wrongly predicted 
tokens into a tab separated file.

Tested with Python 3.7

References:
    - Lin et al. (2020).
      A  recipe  for  creating  multimodal  aligned datasets for sequential tasks.
      In Proceedings of the58th Annual Meeting of the Association for Computational Linguistics, pages 4871â€“4884, Online.
      Association for Computational Linguistics.
    - CoNLL-U: https://universaldependencies.org/format.html
"""

import argparse
import json
from ast import literal_eval
import logging


def read_prediction_tokens(pred_file):
    """
    Reads in the tokens from the tagger's output file.

    Returns: a String list
    """
    tokens = []
    with open(pred_file, encoding="utf-8") as f:
        for line in f:
            j = json.loads(line)
            tokens.extend(j["words"])
    return tokens


def read_prediction_tags(pred_file):
    """
    Reads in the predicted tags from the tagger's output file. Or the
    tags used as part of the input for the parser.
    Also determines the source of the data, i.e. whether it was
    generated by the tagger or the parser.

    Returns: a String list with the predicted tags.
    """
    model_type = None
    tags = []
    with open(pred_file, encoding="utf-8") as f:
        for line in f:
            j = json.loads(line)
            try:
                tags.extend(j["tags"])
                model_type = "tagger"
            except KeyError:
                tags.extend(j["pos"])
                model_type = "parser"
    return tags, model_type


def read_prediction_dependencies(pred_file):
    """
    Reads in the predictions from the parser's output file.

    Returns: two String list with the predicted heads and dependency names, respectively.
    """
    heads = []
    deps = []
    with open(pred_file, encoding="utf-8") as f:
        for line in f:
            j = json.loads(line)
            heads.extend(j["predicted_heads"])
            deps.extend(j["predicted_dependencies"])
    heads = list(map(str, heads))
    return heads, deps


def write_with_misjudgements(gold, prediction, goldlines, out_file):
    """
    Writes a tsv file with the first columns repeating the gold annotated
    file. The last column contains all predictions that do not match the
    gold annotation. If the prediction was correct, the last column in
    that line stays empty.
    """
    with open(out_file, "w", encoding="utf-8") as f:
        for g, p, line in zip(gold, prediction, goldlines):
            s = "\t".join(line)
            if g != p:
                s += "\t" + str(p)
            f.write(s + "\n")


def _read_gold_conllu_simplified(gold_file):
    """
    Reads in the gold annotation from a file in CoNLL-U format.
    WARNING: Does not read in extra edges in 9th column!

    Returns:
        - tags: a String list containing one sequence tag per line.
                E.g. [B-Kochschritt, L-Kochschritt, U-Zutat, O]
        - heads: a String list containing one head reference (its token ID)
                 per line.
        - deps: a String list containing one dependency name per line for the
                relation between the token in that line and the token at the
                ID of 'head'.
        - lines: a list list containing the original line split at "\t"
    """
    tags = []
    heads = []
    deps = []
    lines = []
    with open(gold_file, encoding="utf-8") as f:
        for line in f:
            if line == "\n":
                continue
            line = line.split("\t")
            try:
                tags.append(line[4])
                heads.append(line[6])
                deps.append(line[7])
            except IndexError:
                raise IndexError(
                    f"Gold file {gold_file} probably isn't written in CoNLL-U format."
                )
            lines.append(line[:-1])
    return tags, heads, deps, lines

def read_gold_conll2003(gold_file):
    """
    Reads in the gold annotation from a file in CoNLL 2003 format.

    Returns:
        - gold: a String list containing one sequence tag per token.
                E.g. [B-Kochschritt, L-Kochschritt, U-Zutat, O]
        - lines: a list list containing the original line split at "\t"
    """
    gold = []
    lines = []
    with open(gold_file, encoding="utf-8") as f:
        for line in f:
            if line == "\n":
                continue
            line = line.strip().split("\t")
            gold.append(line[3])
            lines.append(line)
    return gold, lines

def execute_analysis(args):
    """
    Reads in a gold annotated file and predicted data.
    Writes a new file where the first columns repeat the gold annotated file.
    The last column contains all predictions that do not match the gold annotation.
    If the prediction was correct, the last column in that line stays empty.
    """

    # Read in prediction for the sequence tagging task
    # and find out whether the predicted items are tags or edges
    pred_tags, model_type = read_prediction_tags(args.pred_file)

    if args.mode == "parser":
        # Print feedback to console
        logging.info(
            "Comparing edges in "
            + args.pred_file
            + "\nto edges in"
            + args.gold_file
            + ",\nwriting results into "
            + args.out
        )

        # Read in gold_file
        gold_tags, gold_heads, gold_deps, goldlines = _read_gold_conllu_simplified(
            args.gold_file
        )
        # Read in prediction for the parsing task
        pred_heads, pred_deps = read_prediction_dependencies(args.pred_file)
        # Combine prediction and expectation into a tsv file
        write_with_misjudgements(
            zip(gold_heads, gold_deps),
            zip(pred_heads, pred_deps),
            goldlines,
            args.out,
        )
    elif args.mode == "tagger":
        # Print feedback to console
        logging.info(
            "Comparing tags in "
            + args.pred_file
            + "\nto tags in"
            + args.gold_file
            + ",\nwriting results into "
            + args.out
        )

        if args.format == "conllu":
            # Read in gold_file in CoNLL-U format
            gold_tags, gold_heads, gold_deps, goldlines = _read_gold_conllu_simplified(
                args.gold_file
            )
        elif args.format == "conll03":
            # Read in gold file in CoNLL-2003 format (doesn't double-check whether args.gold_file actually
            # is written in CoNLL-2003 format
            gold_tags, goldlines = read_gold_conll2003(args.gold_file)
        # Combine prediction and expectation into a tsv file
        write_with_misjudgements(gold_tags, pred_tags, goldlines, args.out)


if __name__ == "__main__":

    # parser for command line arguments
    arg_parser = argparse.ArgumentParser(
        description="""Generate Error Analysis file for either tagger or parser output."""
    )
    arg_parser.add_argument(
        "-m",
        "--mode",
        dest="mode",
        choices=['tagger', 'parser'],
        required=True,
        help="""Specify mode. Choose one of the following: {tagger, parser}.""",
    )
    arg_parser.add_argument(
        "-p",
        "--prediction",
        dest="pred_file",
        metavar="PRED_FILE",
        required=True,
        help="""Prediction file in json format. Output of AllenNLP parser.""",
    )
    arg_parser.add_argument(
        "-g",
        "--gold",
        dest="gold_file",
        metavar="GOLD_FILE",
        required=True,
        help="""Annotated (gold) file in CoNLL2003 or CoNLL-U format.""",
    )
    arg_parser.add_argument(
        "-f",
        "--format",
        dest="format",
        choices=['conllu', 'conll03'],
        metavar="FORMAT",
        help="""Specify gold file format, one of: {'conllu', 'conll03'} (optional, by default uses file extension).""",
    )
    arg_parser.add_argument(
        "-o",
        "--output_file",
        dest="out",
        metavar="OUTPUT_FILE",
        help="""Name of the output file. (optional, default: <prediction_file>.tsv)""",
    )
    args = arg_parser.parse_args()

    args.debug = False

    # file format detection
    if args.format == None:
        if str(args.gold_file).endswith(".conll03"):
            args.format = "conll03"
        elif  str(args.gold_file).endswith(".conllu"):
            args.format = "conllu"
        else:
            raise RuntimeError(
                "Gold file format is neither specified nor can be detected. Please specify file format or check your file extensions."
            )

    if args.mode == "parser" and args.format == "conll03":
        raise RuntimeError(
            "Parser gold file cannot be in CoNLL-2003 file. Please check your inputs again."
        )

    # default output file name
    if args.out == None:
        args.out = str(args.pred_file)[:-4] + "tsv"

    #########################
    #### Start execution ####
    #########################

    execute_analysis(args)